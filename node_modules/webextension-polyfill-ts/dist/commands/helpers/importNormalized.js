"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const readSchemaFile_1 = require("./readSchemaFile");
const fixes_1 = require("./fixes");
function isExtensionNamespace(entry) {
    if (entry.types && entry.types.find((t) => !!t.$extend))
        return true;
    if (Object.getOwnPropertyNames(entry).length === 2 && entry.permissions)
        return entry.namespace !== 'privacy';
    return false;
}
class ImportedNamespace {
    constructor(file, comments, entry) {
        this.comments = '';
        this.file = file;
        this.entry = entry;
        const lines = comments.split('\n');
        this.comments = lines.map((line) => {
            line = line.trim();
            if (line.startsWith('// ') || line.startsWith('/* '))
                return line.substr(3).trim();
            else if (line.startsWith('* ')) {
                if (line.endsWith('*/'))
                    return line.substr(2, line.length - 4).trim();
                else
                    return line.substr(2).trim();
            }
            else if (line === '')
                return '';
            else
                throw new Error('Unknown comment style:' + line + comments);
        }).join('\n');
    }
    appendComments(comments) {
        if (this.comments.indexOf(comments) === -1)
            this.comments += '\n\n' + comments;
    }
}
exports.ImportedNamespace = ImportedNamespace;
const EXTENSION_NAMESPACE_FILES = [
    'menus_child.json',
    'user_scripts_content.json'
];
class ImportedNamespaces {
    constructor() {
        this.namespaceExtensions = [];
        this.namespaces = {};
    }
    getSubNamespaces(namespace) {
        const result = [];
        const prefix = namespace + '.';
        for (const key in this.namespaces) {
            if (key.startsWith(prefix))
                result.push(key);
        }
        return result;
    }
    importFile(data) {
        if (data.file === 'native_manifest.json')
            return;
        data.json.forEach((entry) => {
            if (entry.namespace === 'test')
                return;
            if (isExtensionNamespace(entry) || EXTENSION_NAMESPACE_FILES.indexOf(data.file) >= 0) {
                this.namespaceExtensions.push(new ImportedNamespace(data.file, data.comments, entry));
                return;
            }
            if (this.namespaces.hasOwnProperty(entry.namespace))
                throw new Error('Namespace already exists: ' + entry.namespace);
            this.namespaces[entry.namespace] = new ImportedNamespace(data.file, data.comments, entry);
        });
    }
}
exports.ImportedNamespaces = ImportedNamespaces;
function importAndFixAll() {
    const result = new ImportedNamespaces();
    try {
        const files = fs.readdirSync('./schemas');
        files.map(readSchemaFile_1.readSchemaFile).forEach((data) => {
            console.log('- ' + data.file);
            result.importFile(data);
        });
    }
    catch (e) {
        console.error('Error:', e);
        return null;
    }
    console.log('--------------------');
    for (let i = 0; i < fixes_1.fixes.length; i++) {
        const fix = fixes_1.fixes[i];
        try {
            console.log(fix.name);
            fix.apply(result);
        }
        catch (e) {
            console.error('Error:', e);
            return null;
        }
    }
    console.log('--------------------');
    return result;
}
exports.importAndFixAll = importAndFixAll;
//# sourceMappingURL=importNormalized.js.map