"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
const assert_1 = require("./assert");
const stripUnusedContent_1 = require("./stripUnusedContent");
const extractInlineContent_1 = require("./extractInlineContent");
const getType_1 = require("./getType");
function fixPropertyType(prop) {
    if (prop.choices)
        prop.type = 'choices';
    else if (prop.properties)
        prop.type = 'object';
    else if (prop.hasOwnProperty('value'))
        prop.type = 'value';
    if (prop.type === 'array' && prop.items)
        fixPropertyType(prop.items);
    else if (prop.type === 'function') {
        utils_1.workArray(prop.parameters, fixPropertyType);
        if (prop.returns)
            fixPropertyType(prop.returns);
    }
    else if (prop.type === 'object') {
        utils_1.workMap(prop.properties, fixPropertyType);
        utils_1.workMap(prop.patternProperties, fixPropertyType);
        utils_1.workArray(prop.functions, fixPropertyType);
    }
}
function flattenChoiceEnum(prop, types) {
    if (prop.type === 'object') {
        utils_1.workMap(prop.properties, (p) => flattenChoiceEnum(p, types));
        return;
    }
    if (prop.type === 'function') {
        utils_1.workArray(prop.parameters, (p) => flattenChoiceEnum(p, types));
        return;
    }
    const choices = prop.type === 'choices' && prop.choices;
    const choice0 = choices && choices.length === 1 && choices[0];
    if (choice0 && choice0.$ref && choice0.$ref.endsWith('Enum')) {
        const extended = types.find((t2) => t2.id === choice0.$ref);
        if (!extended)
            throw new Error('Could not find extended');
        //@ts-ignore
        const stringProp = prop;
        stringProp.type = 'string';
        if (extended.type !== 'string')
            throw new Error('error flattening single choice, both must be string');
        stringProp.enum = extended.enum;
        extended.deprecated = true; // so it gets removed in the next step
    }
    else if (choices) {
        utils_1.modifyArray(choices, (c) => {
            if (c.$ref && c.$ref.endsWith('Enum')) {
                const extended = types.find((t2) => t2.id === c.$ref);
                if (!extended)
                    throw new Error('Could not find extended');
                if (extended.type !== 'string')
                    throw new Error('error flattening single choice, both must be string');
                if (extended.enum) {
                    extended.deprecated = true; // so it gets removed in the next step
                    return { type: 'value', value: getType_1.getEnumType(extended.enum) };
                }
            }
            return c;
        });
    }
}
exports.fixes = [{
        name: 'removing unused namespaces',
        apply: (namespaces) => {
            delete namespaces.namespaces.test;
        }
    }, {
        name: 'correcting types',
        apply: (namespaces) => {
            utils_1.workMap(namespaces.namespaces, (namespace) => {
                utils_1.workArray(namespace.entry.types, fixPropertyType);
                utils_1.workArray(namespace.entry.functions, (f) => {
                    if (f.parameters)
                        f.parameters.forEach(fixPropertyType);
                    if (f.returns)
                        fixPropertyType(f.returns);
                });
                utils_1.workMap(namespace.entry.properties, fixPropertyType);
            });
        }
    }, {
        name: 'applying namespace extensions',
        apply: (namespaces) => {
            namespaces.namespaceExtensions.forEach((e) => {
                const namespace = namespaces.namespaces[e.entry.namespace];
                if (!namespace)
                    throw new Error('Missing namespace to extend: ' + e.entry.namespace);
                namespace.appendComments(e.comments);
                if (!namespace.entry.types)
                    namespace.entry.types = [];
                const types = namespace.entry.types;
                utils_1.workArray(e.entry.types, (t) => {
                    if (!t.$extend) {
                        fixPropertyType(t);
                        types.push(t);
                        return;
                    }
                    const extended = types.find((t2) => t2.id === t.$extend);
                    if (!extended)
                        throw new Error('Could not find type to extend: ' + t.$extend);
                    if (t.choices) {
                        assert_1.assertValidOjectKeys(t, ['$extend', 'choices']);
                        t.type = 'choices';
                    }
                    else if (t.properties) {
                        assert_1.assertValidOjectKeys(t, ['$extend', 'properties']);
                        t.type = 'object';
                    }
                    else {
                        throw new Error('Unknown extension type ' + t.$extend);
                    }
                    if (t.type === 'choices' && t.choices && extended.type === 'choices' && extended.choices) {
                        const choices = extended.choices;
                        const onlyEnums = t.choices.findIndex((c) => c.type !== 'string' || !c.enum) === -1;
                        const enumToExtend = choices.find((c) => c.type === 'string' && !!c.enum);
                        if (onlyEnums && enumToExtend && enumToExtend.type === 'string' && enumToExtend.enum) {
                            const enumArray = enumToExtend.enum;
                            t.choices.forEach((c) => {
                                if (c.type === 'string' && c.enum)
                                    c.enum.forEach((e) => enumArray.push(e));
                            });
                        }
                        else {
                            t.choices.forEach((c) => choices.push(c));
                        }
                    }
                    else if (t.type === 'object' && t.properties && extended.type === 'object' && extended.properties) {
                        const properties = extended.properties;
                        for (const key in t.properties)
                            properties[key] = t.properties[key];
                    }
                    else {
                        throw new Error('Bad $extend');
                    }
                });
                if (!namespace.entry.functions)
                    namespace.entry.functions = [];
                const functions = namespace.entry.functions;
                utils_1.workArray(e.entry.functions, (t) => functions.push(t));
            });
        }
    }, {
        name: 'applying manual json fixes',
        apply: (namespaces) => {
            const fixes = utils_1.readJsonFile('./fixes.json');
            for (const path in fixes) {
                const parts = path.split('.');
                let base = namespaces.namespaces[parts[0]].entry;
                for (let i = 1; i < (parts.length - 1); i++) {
                    const part = parts[i];
                    if (part[0] === '$') {
                        const id = part.substr(1);
                        assert_1.assertType(base, 'array');
                        base = base.find((e) => e.id === id);
                        assert_1.assertType(base, 'array', 'object');
                    }
                    else if (part[0] === '%') {
                        const name = part.substr(1);
                        assert_1.assertType(base, 'array');
                        base = base.find((e) => e.name === name);
                        assert_1.assertType(base, 'array', 'object');
                        assert_1.assertType(base, 'array', 'object');
                    }
                    else if (part[0] === '#') {
                        assert_1.assertType(base, 'array');
                        const index = parseInt(part.substr(1));
                        if (index >= base.length || index < 0)
                            throw new Error('Index out of bounds');
                        base = base[index];
                        assert_1.assertType(base, 'array', 'object');
                    }
                    else {
                        base = base[part];
                        assert_1.assertType(base, 'array', 'object');
                    }
                }
                const lastPart = parts[parts.length - 1];
                const value = fixes[path];
                if (lastPart === '+[]') {
                    assert_1.assertType(base, 'array');
                    assert_1.assertType(value, 'array');
                    value.forEach((e) => base.push(e));
                }
                else if (lastPart === "!fixAsync") {
                    assert_1.assertEqual(base.async, true);
                    assert_1.assertType(base.parameters, 'array');
                    base.async = "callback";
                    const params = [];
                    if (value) {
                        const [name, type] = value.split(":");
                        params.push({ name, type });
                    }
                    base.parameters.push({
                        "type": "function",
                        "name": "callback",
                        "parameters": params
                    });
                }
                else {
                    if (value === null && Array.isArray(base)) {
                        let index;
                        if (lastPart[0] === '$') {
                            const id = lastPart.substr(1);
                            index = base.findIndex((e) => e.id === id);
                        }
                        else if (lastPart[0] === '%') {
                            const name = lastPart.substr(1);
                            index = base.findIndex((e) => e.name === name);
                        }
                        else {
                            throw new Error('Unknown method to remove from array: ' + lastPart);
                        }
                        if (index === -1)
                            throw new Error("Could not find " + lastPart);
                        base.splice(index, 1);
                    }
                    else {
                        base[lastPart] = value;
                    }
                }
            }
        }
    }, {
        name: 'extracting inline content',
        apply: (namespaces) => {
            utils_1.workMap(namespaces.namespaces, (ns) => extractInlineContent_1.extractInlineContent(ns.entry));
        }
    }, {
        name: 'flatten choice enum',
        apply: (namespaces) => {
            //fixme: improve this further if possible
            utils_1.workMap(namespaces.namespaces, (ns) => {
                const types = ns.entry.types;
                if (!types)
                    return;
                utils_1.workArray(ns.entry.functions, (t) => flattenChoiceEnum(t, types));
                utils_1.workArray(ns.entry.events, (t) => flattenChoiceEnum(t, types));
                utils_1.workArray(ns.entry.types, (t) => flattenChoiceEnum(t, types));
                utils_1.workMap(ns.entry.properties, (p) => flattenChoiceEnum(p, types));
            });
        }
    }, {
        name: 'remove unsupported and deprecated content',
        apply: (namespaces) => {
            utils_1.workMap(namespaces.namespaces, (ns) => stripUnusedContent_1.stripUnusedContent(ns.entry));
        }
    }, {
        name: 'extend events if needed',
        apply: (namespaces) => {
            const types = namespaces.namespaces.events.entry.types;
            if (!types)
                throw new Error('Missing events types');
            const eventType = types.find((t) => t.id === 'Event');
            if (!eventType)
                throw new Error('Missing Events.Event');
            if (eventType.type !== 'object')
                throw new Error('Events.Event should be object');
            const eventFunctions = eventType.functions;
            if (!eventFunctions)
                throw new Error('Events.Event.functions missing');
            const addListener = eventFunctions.find((f) => f.name === 'addListener');
            if (!addListener)
                throw new Error('Missing addListener in Event type');
            utils_1.workMap(namespaces.namespaces, (ns) => {
                utils_1.workArray(ns.entry.events, (e) => {
                    if (e.extraParameters) {
                        const id = e.name + 'Event';
                        const extendedAddListener = JSON.parse(JSON.stringify(addListener));
                        const extended = {
                            id,
                            type: "object",
                            additionalProperties: { $ref: 'Events.Event<(' + getType_1.getParameters(e.parameters, false) + ') => ' + getType_1.getReturnType(e) + '>', type: 'ref' },
                            description: e.description,
                            functions: [extendedAddListener]
                        };
                        const params = extendedAddListener.parameters;
                        if (!params)
                            throw new Error('Missing addListener.parameters in Event type');
                        params[0].type = '(' + getType_1.getParameters(e.parameters, false) + ') => ' + getType_1.getReturnType(e);
                        params.pop();
                        e.extraParameters.forEach((p) => params.push(p));
                        e.$extend = id;
                        delete e.parameters;
                        if (!ns.entry.types)
                            ns.entry.types = [];
                        ns.entry.types.push(extended);
                    }
                });
            });
        }
    }];
//Fixme: copy permissions from ns to subns
//# sourceMappingURL=fixes.js.map