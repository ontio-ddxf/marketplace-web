"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = require("./assert");
exports.typeById = {};
class SchemaBaseProperty {
    static getValidKeys() {
        return [
            'id',
            'name',
            '$extend',
            'description',
            'optional',
            'unsupported',
            'deprecated',
            'permissions',
            'allowedContexts',
            'onError'
        ];
    }
    static validate(json) {
        assert_1.assertType(json, 'object');
        assert_1.assertType(json.id, 'string', 'undefined');
        assert_1.assertType(json.name, 'string', 'undefined');
        assert_1.assertType(json.$extend, 'string', 'undefined');
        assert_1.assertType(json.description, 'string', 'undefined');
        assert_1.assertOneOf(json.optional, true, false, 'true', 'false', 'omit-key-if-missing', undefined);
        assert_1.assertOneOf(json.unsupported, true, false, 'true', 'false', undefined);
        assert_1.assertType(json.deprecated, 'boolean', 'string', 'undefined');
        assert_1.assertType(json.permissions, 'array', 'undefined');
        assert_1.assertArray(json.permissions, (s) => assert_1.assertType(s, 'string'));
        assert_1.assertType(json.allowedContexts, 'array', 'undefined');
        assert_1.assertArray(json.allowedContexts, (s) => assert_1.assertType(s, 'string'));
        assert_1.assertOneOf(json.onError, 'warn', undefined);
    }
}
exports.SchemaBaseProperty = SchemaBaseProperty;
let currentNamespace = '';
function getReducedRefJson(json, attr) {
    let id = json[attr];
    assert_1.assertType(id, 'string');
    //hacks due to incorrect data:
    id = id.replace('contextMenusInternal', 'menusInternal').replace('UnrecognizedProperty', 'manifest.UnrecognizedProperty');
    const normalizedId = id.indexOf('.') >= 0 ? id : (currentNamespace + '.' + id);
    const inherit = exports.typeById[normalizedId];
    if (!inherit)
        throw new Error(`Could not find id '${normalizedId}' in registry`);
    const result = Object.assign({}, json);
    if (inherit.choices)
        result.choices = inherit.choices;
    else if (inherit.type)
        result.type = inherit.type;
    delete result[attr];
    return result;
}
function validateSchemaProperty(json) {
    assert_1.assertType(json, 'object');
    if (json.unsupported)
        return;
    if (json.$ref)
        json = getReducedRefJson(json, '$ref');
    else if (json.$extend)
        json = getReducedRefJson(json, '$extend');
    if (json.choices)
        SchemaChoicesProperty.validate(json);
    else if (json.value)
        SchemaValueProperty.validate(json);
    else {
        switch (json.type) {
            case 'number':
            case 'integer':
                return SchemaNumberProperty.validate(json);
            case 'string':
                return SchemaStringProperty.validate(json);
            case 'array':
                return SchemaArrayProperty.validate(json);
            case 'object':
                return SchemaObjectProperty.validate(json);
            case 'boolean':
                return SchemaBooleanProperty.validate(json);
            case 'function':
                return SchemaFunctionProperty.validate(json);
            case 'any':
                return SchemaAnyProperty.validate(json);
            case 'null':
                return SchemaNullProperty.validate(json);
            default:
                throw new Error('unknown type: ' + json.type);
        }
    }
}
function validateSchemaPropertyWithoutExtend(json) {
    validateSchemaProperty(json);
    if (json.$extend)
        throw new Error('Only types may contain $extend');
}
class SchemaChoicesProperty extends SchemaBaseProperty {
    constructor() {
        super(...arguments);
        this.type = 'choices'; //fixme
    }
    static getValidKeys() {
        return super.getValidKeys().concat([
            'choices',
            'preprocess'
        ]);
    }
    static validate(json) {
        super.validate(json);
        assert_1.assertValidOjectKeys(json, this.getValidKeys());
        assert_1.assertType(json.choices, 'array', 'undefined');
        assert_1.assertArray(json.allowedContexts, validateSchemaPropertyWithoutExtend);
    }
}
exports.SchemaChoicesProperty = SchemaChoicesProperty;
class SchemaAnyProperty extends SchemaBaseProperty {
    constructor() {
        super(...arguments);
        this.type = 'any';
    }
    static getValidKeys() {
        return super.getValidKeys().concat([
            'type'
        ]);
    }
    static validate(json) {
        super.validate(json);
        assert_1.assertValidOjectKeys(json, this.getValidKeys());
        assert_1.assertEqual(json.type, 'any');
    }
}
exports.SchemaAnyProperty = SchemaAnyProperty;
class SchemaRefProperty extends SchemaBaseProperty {
    constructor() {
        super(...arguments);
        this.type = 'ref';
    }
    static getValidKeys() {
        return super.getValidKeys().concat([
            'type'
        ]);
    }
    static validate(json) {
        super.validate(json);
        assert_1.assertValidOjectKeys(json, this.getValidKeys());
        assert_1.assertType(json.$type, 'object');
    }
}
exports.SchemaRefProperty = SchemaRefProperty;
class SchemaNullProperty extends SchemaBaseProperty {
    constructor() {
        super(...arguments);
        this.type = 'null';
    }
    static getValidKeys() {
        return super.getValidKeys().concat([
            'type'
        ]);
    }
    static validate(json) {
        super.validate(json);
        assert_1.assertValidOjectKeys(json, this.getValidKeys());
        assert_1.assertEqual(json.type, 'null');
    }
}
exports.SchemaNullProperty = SchemaNullProperty;
class SchemaValueProperty extends SchemaBaseProperty {
    constructor() {
        super(...arguments);
        this.type = 'value'; //fixme
    }
    static getValidKeys() {
        return super.getValidKeys().concat([
            'value'
        ]);
    }
    static validate(json) {
        super.validate(json);
        assert_1.assertValidOjectKeys(json, this.getValidKeys());
        if (typeof (json.value) === "undefined")
            throw new Error('Value expected');
    }
}
exports.SchemaValueProperty = SchemaValueProperty;
function validateEnumValue(json) {
    assert_1.assertType(json, 'string', 'object', 'undefined');
    if (typeof (json) === 'object') {
        assert_1.assertValidOjectKeys(json, ['name', 'description']);
        assert_1.assertType(json.name, 'string');
        assert_1.assertType(json.description, 'string');
    }
}
class SchemaStringProperty extends SchemaBaseProperty {
    constructor() {
        super(...arguments);
        this.type = 'string';
    }
    static getValidKeys() {
        return super.getValidKeys().concat([
            'type',
            'preprocess',
            'enum',
            'minLength',
            'maxLength',
            'pattern',
            'format',
            'default'
        ]);
    }
    static validate(json) {
        super.validate(json);
        assert_1.assertValidOjectKeys(json, this.getValidKeys());
        assert_1.assertEqual(json.type, 'string');
        assert_1.assertOneOf(json.preprocess, 'localize', undefined);
        assert_1.assertType(json.enum, 'array', 'undefined');
        assert_1.assertArray(json.enum, (e) => validateEnumValue(e));
        assert_1.assertType(json.minLength, 'number', 'undefined');
        assert_1.assertType(json.maxLength, 'number', 'undefined');
        assert_1.assertType(json.pattern, 'string', 'undefined');
        assert_1.assertType(json.format, 'string', 'undefined');
        assert_1.assertType(json.default, 'string', 'undefined');
    }
}
exports.SchemaStringProperty = SchemaStringProperty;
class SchemaObjectProperty extends SchemaBaseProperty {
    constructor() {
        super(...arguments);
        this.type = 'object';
    }
    static getValidKeys() {
        return super.getValidKeys().concat([
            'type',
            'properties',
            'additionalProperties',
            'patternProperties',
            '$import',
            'isInstanceOf',
            'postprocess',
            'functions',
            'events',
            'default'
        ]);
    }
    static validate(json) {
        super.validate(json);
        assert_1.assertValidOjectKeys(json, this.getValidKeys());
        assert_1.assertEqual(json.type, 'object');
        assert_1.assertType(json.properties, 'object', 'undefined');
        assert_1.assertMap(json.properties, validateSchemaPropertyWithoutExtend);
        assert_1.assertType(json.additionalProperties, 'object', 'boolean', 'undefined');
        if (typeof (json.additionalProperties) === 'object')
            validateSchemaPropertyWithoutExtend(json.additionalProperties);
        assert_1.assertType(json.patternProperties, 'object', 'undefined');
        assert_1.assertMap(json.patternProperties, validateSchemaPropertyWithoutExtend);
        assert_1.assertType(json.$import, 'string', 'undefined');
        assert_1.assertType(json.isInstanceOf, 'string', 'undefined');
        assert_1.assertOneOf(json.postprocess, 'convertImageDataToURL', undefined);
        assert_1.assertType(json.functions, 'array', 'undefined');
        assert_1.assertArray(json.functions, (e) => SchemaFunctionProperty.validate(e));
        assert_1.assertType(json.events, 'array', 'undefined');
        assert_1.assertArray(json.events, (e) => SchemaFunctionProperty.validate(e));
        assert_1.assertType(json.default, 'object', 'undefined');
    }
}
exports.SchemaObjectProperty = SchemaObjectProperty;
class SchemaNumberProperty extends SchemaBaseProperty {
    constructor() {
        super(...arguments);
        this.type = 'number';
    }
    static getValidKeys() {
        return super.getValidKeys().concat([
            'type',
            'minimum',
            'maximum',
            'default'
        ]);
    }
    static validate(json) {
        super.validate(json);
        assert_1.assertValidOjectKeys(json, this.getValidKeys());
        assert_1.assertOneOf(json.type, 'integer', 'number');
        assert_1.assertType(json.minimum, 'number', 'undefined');
        assert_1.assertType(json.maximum, 'number', 'undefined');
        assert_1.assertType(json.default, 'number', 'undefined');
    }
}
exports.SchemaNumberProperty = SchemaNumberProperty;
class SchemaBooleanProperty extends SchemaBaseProperty {
    constructor() {
        super(...arguments);
        this.type = 'boolean';
    }
    static getValidKeys() {
        return super.getValidKeys().concat([
            'type',
            'default'
        ]);
    }
    static validate(json) {
        super.validate(json);
        assert_1.assertValidOjectKeys(json, this.getValidKeys());
        assert_1.assertEqual(json.type, 'boolean');
        assert_1.assertType(json.default, 'boolean', 'undefined');
    }
}
exports.SchemaBooleanProperty = SchemaBooleanProperty;
class SchemaArrayProperty extends SchemaBaseProperty {
    constructor() {
        super(...arguments);
        this.type = 'array';
    }
    static getValidKeys() {
        return super.getValidKeys().concat([
            'type',
            'items',
            'minItems',
            'maxItems',
            'default'
        ]);
    }
    static validate(json) {
        super.validate(json);
        assert_1.assertValidOjectKeys(json, this.getValidKeys());
        assert_1.assertEqual(json.type, 'array');
        assert_1.assertType(json.items, 'object', 'undefined');
        if (json.items)
            validateSchemaPropertyWithoutExtend(json.items);
        assert_1.assertType(json.minItems, 'number', 'undefined');
        assert_1.assertType(json.maxItems, 'number', 'undefined');
        assert_1.assertType(json.default, 'array', 'undefined');
        if (json.default)
            assert_1.assertEqual(json.default.length, 0);
    }
}
exports.SchemaArrayProperty = SchemaArrayProperty;
class SchemaFunctionProperty extends SchemaBaseProperty {
    constructor() {
        super(...arguments);
        this.type = 'function';
    }
    static getValidKeys() {
        return super.getValidKeys().concat([
            'type',
            'async',
            'requireUserInput',
            'parameters',
            'extraParameters',
            'returns',
            'allowAmbiguousOptionalArguments',
            'filters'
        ]);
    }
    static validate(json) {
        super.validate(json);
        assert_1.assertValidOjectKeys(json, this.getValidKeys());
        assert_1.assertOneOf(json.type, 'function', undefined); //hack: sometimes not set.
        assert_1.assertOneOf(json.async, 'callback', 'responseCallback', true, false, undefined);
        assert_1.assertType(json.requireUserInput, 'boolean', 'undefined');
        assert_1.assertType(json.parameters, 'array', 'undefined');
        assert_1.assertArray(json.parameters, validateSchemaPropertyWithoutExtend);
        assert_1.assertType(json.extraParameters, 'array', 'undefined');
        assert_1.assertArray(json.extraParameters, validateSchemaPropertyWithoutExtend);
        assert_1.assertType(json.returns, 'object', 'undefined');
        if (json.returns)
            validateSchemaPropertyWithoutExtend(json.returns);
        assert_1.assertType(json.allowAmbiguousOptionalArguments, 'boolean', 'undefined');
        assert_1.assertType(json.filters, 'array', 'undefined');
        assert_1.assertArray(json.filters, validateSchemaPropertyWithoutExtend);
    }
}
exports.SchemaFunctionProperty = SchemaFunctionProperty;
class SchemaEntry {
    constructor() {
        this.namespace = '';
    }
    static getValidKeys() {
        return [
            'namespace',
            'description',
            'permissions',
            'types',
            'functions',
            'events',
            'properties',
            'allowedContexts',
            'defaultContexts',
            'nocompile',
            '$import'
        ];
    }
    static validate(json) {
        assert_1.assertType(json, 'object');
        assert_1.assertType(json.namespace, 'string');
        currentNamespace = json.namespace;
        assert_1.assertType(json.description, 'string', 'undefined');
        assert_1.assertType(json.permissions, 'array', 'undefined');
        assert_1.assertArray(json.permissions, (e) => assert_1.assertType(e, 'string'));
        assert_1.assertType(json.types, 'array', 'undefined');
        assert_1.assertArray(json.types, validateSchemaProperty);
        assert_1.assertType(json.functions, 'array', 'undefined');
        assert_1.assertArray(json.functions, (e) => SchemaFunctionProperty.validate(e));
        assert_1.assertType(json.events, 'array', 'undefined');
        assert_1.assertArray(json.events, (e) => SchemaFunctionProperty.validate(e));
        assert_1.assertType(json.properties, 'object', 'undefined');
        assert_1.assertMap(json.properties, validateSchemaPropertyWithoutExtend);
        assert_1.assertType(json.allowedContexts, 'array', 'undefined');
        assert_1.assertArray(json.allowedContexts, (e) => assert_1.assertType(e, 'string'));
        assert_1.assertType(json.defaultContexts, 'array', 'undefined');
        assert_1.assertArray(json.defaultContexts, (e) => assert_1.assertType(e, 'string'));
        assert_1.assertType(json.nocompile, 'boolean', 'undefined');
        assert_1.assertType(json.$import, 'string', 'undefined');
    }
}
exports.SchemaEntry = SchemaEntry;
//# sourceMappingURL=types.js.map