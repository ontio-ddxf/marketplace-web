"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
const assert_1 = require("./assert");
function convertToRef(prop, id, entry) {
    const newProp = { $ref: id, type: 'ref' };
    if (prop.name)
        newProp.name = prop.name;
    if (prop.description)
        newProp.description = prop.description;
    if (!entry.types)
        entry.types = [];
    if (prop.optional)
        newProp.optional = prop.optional;
    delete prop.name;
    prop.id = id;
    entry.types.push(prop);
    return newProp;
}
function combineNamePrefix(namePrefix, suffix) {
    if (suffix)
        return namePrefix + utils_1.toUpperCamelCase(suffix);
    return namePrefix;
}
function convertToRefIfObject(prop, propName, namePrefix, entry) {
    if (prop.type === 'object' && prop.additionalProperties && prop.additionalProperties !== true && prop.additionalProperties.$ref && !prop.properties) {
        //special case for a map type.. not extracted, will be handled in getType
    }
    else if (prop.type === 'object' && !prop.isInstanceOf && !prop.patternProperties) {
        if (!namePrefix)
            throw assert_1.ErrorMessage.MISSING_NAME;
        const name = combineNamePrefix(namePrefix, propName);
        const id = utils_1.toUpperCamelCase(name) + 'Type';
        const newRef = convertToRef(prop, id, entry);
        // extractParameterObjectFromProperty(params[i], name, entry, false);
        return newRef;
    }
    else if (prop.type === 'string' && prop.enum) {
        if (!namePrefix)
            throw assert_1.ErrorMessage.MISSING_NAME;
        const name = combineNamePrefix(namePrefix, propName);
        const id = utils_1.toUpperCamelCase(name) + 'Enum';
        return convertToRef(prop, id, entry);
    }
    else if (prop.type === 'choices' && prop.choices) {
        if (prop.choices.length === 1)
            prop.choices[0] = convertToRefIfObject(prop.choices[0], propName, namePrefix, entry);
        else {
            utils_1.modifyArray(prop.choices, (choice, i) => {
                return convertToRefIfObject(choice, propName + 'C' + (i + 1), namePrefix, entry);
            });
        }
    }
    else if (prop.type === 'array' && prop.items && (prop.items.type !== 'object' || !prop.items.isInstanceOf)) {
        prop.items = convertToRefIfObject(prop.items, propName + 'Item', namePrefix, entry);
    }
    else if (prop.type === 'function') {
        utils_1.modifyArray(prop.parameters, (param, i) => {
            if (!param.name)
                throw assert_1.ErrorMessage.MISSING_NAME;
            return convertToRefIfObject(param, propName + utils_1.toUpperCamelCase(param.name), namePrefix, entry);
        });
    }
    return prop;
}
function extractParameterObjectFunction(func, entry) {
    utils_1.modifyArray(func.parameters, (param) => {
        if (!param.name)
            throw assert_1.ErrorMessage.MISSING_NAME;
        return convertToRefIfObject(param, param.name, func.name, entry);
    });
    if (func.returns)
        func.returns = convertToRefIfObject(func.returns, 'return', func.name, entry);
}
function extractParameterObjectType(prop, namePrefix, isRoot, entry) {
    if (prop.type === 'object') {
        if (prop.additionalProperties && prop.additionalProperties !== true
            && prop.additionalProperties.type === 'object' && !prop.additionalProperties.$ref) {
            extractParameterObjectType(prop.additionalProperties, namePrefix, true, entry);
        }
        utils_1.modifyMap(prop.properties, (prop, key) => extractParameterObjectType(prop, combineNamePrefix(namePrefix, key), false, entry));
        utils_1.modifyMap(prop.patternProperties, (prop, key) => extractParameterObjectType(prop, namePrefix + "Pattern", false, entry));
        utils_1.modifyArray(prop.events, (evt) => extractParameterObjectType(evt, combineNamePrefix(namePrefix, evt.name), false, entry));
        utils_1.modifyArray(prop.functions, (func) => extractParameterObjectType(func, combineNamePrefix(namePrefix, func.name), false, entry));
        if (!isRoot && !prop.isInstanceOf) {
            if ((!prop.properties || Object.getOwnPropertyNames(prop.properties).length === 0)
                && prop.additionalProperties && prop.additionalProperties !== true && prop.additionalProperties.type === 'array'
                && prop.additionalProperties.items && prop.additionalProperties.items.type) {
                //special case for a map type.. not extracted, will be handled in getType
            }
            else if (prop.patternProperties) {
                //special case for a map type.. not extracted, will be handled in getType
            }
            else {
                if (!namePrefix)
                    throw assert_1.ErrorMessage.MISSING_NAME;
                const id = namePrefix + 'Type';
                prop = convertToRef(prop, id, entry);
            }
        }
    }
    else if (prop.type === 'string' && prop.enum) {
        if (!isRoot) {
            const ref = convertToRefIfObject(prop, "", namePrefix, entry);
            //@ts-ignore
            return ref;
        }
    }
    else if (prop.type === 'array' && prop.items) {
        prop.items = convertToRefIfObject(prop.items, "item", namePrefix, entry);
    }
    else if (prop.type === 'choices' && prop.choices) {
        if (prop.choices.length === 1)
            prop.choices[0] = extractParameterObjectType(prop.choices[0], namePrefix, false, entry);
        else
            utils_1.modifyArray(prop.choices, (choice, i) => extractParameterObjectType(choice, namePrefix + 'C' + (i + 1), false, entry));
    }
    else if (prop.type === 'function') {
        utils_1.modifyArray(prop.parameters, (param, i) => extractParameterObjectType(param, combineNamePrefix(namePrefix, param.name), false, entry));
        utils_1.modifyArray(prop.extraParameters, (param, i) => extractParameterObjectType(param, combineNamePrefix(namePrefix, param.name), false, entry));
        if (prop.returns)
            prop.returns = extractParameterObjectType(prop.returns, 'Return', false, entry);
    }
    // @ts-ignore
    return prop;
}
function extractInlineContent(entry) {
    utils_1.workArray(entry.functions, (func) => extractParameterObjectFunction(func, entry));
    utils_1.workArray(entry.events, (evt) => extractParameterObjectFunction(evt, entry));
    utils_1.modifyMap(entry.properties, (prop, key) => {
        if (prop.$ref && prop.hasOwnProperty('properties')) {
            const id = combineNamePrefix(utils_1.toUpperCamelCase(key), prop.$ref);
            const newProp = {
                type: 'object',
                additionalProperties: { $ref: prop.$ref },
                properties: prop.properties
            };
            //@ts-ignore
            return convertToRef(newProp, id, entry);
        }
        else {
            return convertToRefIfObject(prop, key, 'Property', entry);
        }
    });
    // slice array, since array will be modified during work
    const entryTypes = entry.types && entry.types.slice();
    utils_1.workArray(entryTypes, (type) => {
        if (!type.id)
            throw new Error('Gotta have a prefix, dude!');
        extractParameterObjectType(type, utils_1.toUpperCamelCase(type.id), true, entry);
    });
}
exports.extractInlineContent = extractInlineContent;
//# sourceMappingURL=extractInlineContent.js.map