"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("./types");
const assert_1 = require("./assert");
const fs = require("fs");
function getQuoteLength(text, start, c) {
    for (var i = start; i < text.length; i++) {
        const cc = text[i];
        if (cc === '\\')
            i++;
        else if (cc === c)
            break;
    }
    return i - start;
}
function getSingleLineCommentLength(text, start) {
    for (var i = start; i < text.length; i++) {
        if (text[i] === '\n')
            break;
    }
    return i - start;
}
function getMultiLineCommentLength(text, start) {
    for (var i = start; i < text.length; i++) {
        if (text[i] === '*' && text[i + 1] === '/') {
            i++;
            break;
        }
    }
    return i - start;
}
function splitComments(text) {
    const json = [];
    const comments = [];
    let start = 0, count = 0;
    for (let i = 0; i < text.length; i++) {
        const c = text[i];
        const nc = text[i + 1];
        if (c === '/' && nc === '/') {
            if (count)
                json.push(text.substr(start, count + 1));
            const len = getSingleLineCommentLength(text, i + 1);
            comments.push(text.substr(i, len + 1));
            i += len + 1;
            start = i + 1;
            count = 0;
        }
        else if (c === '/' && nc === '*') {
            if (count)
                json.push(text.substr(start, count + 1));
            const len = getMultiLineCommentLength(text, i + 1);
            comments.push(text.substr(i, len + 2));
            i += len + 1;
            start = i + 1;
            count = 0;
        }
        else if (c === '"' || c === "'") {
            const len = getQuoteLength(text, i + 1, c);
            i += len + 1;
            count += len + 2;
        }
        else {
            count++;
        }
    }
    if (count)
        json.push(text.substr(start, count + 1));
    return {
        comments: comments.join('\n'),
        json: json.join('')
    };
}
function readSchemaFile(file) {
    try {
        const value = fs.readFileSync('./schemas/' + file, { encoding: 'utf-8' });
        const split = splitComments(value);
        const json = JSON.parse(split.json);
        assert_1.assertType(json, 'array');
        json.forEach((e) => {
            if (e.types)
                e.types.forEach((t) => {
                    if (t.id)
                        types_1.typeById[e.namespace + '.' + t.id] = t;
                });
        });
        return { file, json, comments: split.comments };
    }
    catch (e) {
        console.error('Error reading ' + file + ': ', e);
        throw e;
    }
}
exports.readSchemaFile = readSchemaFile;
//# sourceMappingURL=readSchemaFile.js.map